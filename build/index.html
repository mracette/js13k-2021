<html>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1.01">
<title>JS13k 2021</title>

<body>
  <div class="flex flex-centered fill-absolute"><canvas class="centered" id="canvas-pre"></canvas><canvas
      class="centered" id="canvas-tiles"></canvas><canvas class="centered" id="canvas-instruments"></canvas><canvas
      class="centered" id="canvas-oscillators"></canvas><canvas class="centered" id="canvas-post"></canvas><canvas
      class="centered" id="canvas-stats"></canvas>
    <div class="centered flex flex-centered" id="menu">
      <div class="flex flex-col" id="menu-col">
        <p style="height: unset;">Oscillators</p>
        <div style="height: unset;" class="flex flex-centered">
          <div id="co" class="flex flex-col flex-centered" style="justify-content: flex-start;"></div>
          <div id="to" class="flex flex-col flex-centered" style="justify-content: flex-start;"></div>
          <div id="so" class="flex flex-col flex-centered" style="justify-content: flex-start;"></div>
        </div>
        <p style="height: unset;">Instruments</p>
        <div style="height: unset;" class="flex flex-centered">
          <div id="in" class="flex flex-col flex-centered" style="justify-content: flex-start;"></div>
        </div>
      </div>
    </div><button id="menu-button">+</button>
  </div>
  <script>(() => { "use strict"; var t = { 28: (t, s, e) => { e.d(s, { t: () => o }); var i = e(645), n = e.n(i)()((function (t) { return t[1] })); n.push([t.id, "* {\n  color: white;\n  text-align: center;\n  padding: 0;\n  margin: 0;\n  width: 100%;\n  height: 100%;\n  font-size: 1vh;\n  user-select: none;\n}\n\n:disabled {\n  filter: brightness(.5) grayscale(.75)\n}\n\nhtml .fill-absolute {\n  position: absolute;\n  top: 0;\n  left: 0;\n  overscroll-behavior: none;\n}\n\nbody {\n  /* mimics 'overscroll-behavior: none' on ios safari */\n  position: fixed\n}\n\n.flex {\n  display: flex\n}\n\n.flex-col {\n  flex-direction: column;\n}\n\n.flex-centered {\n  align-items: center;\n  justify-content: center;\n}\n\n.centered {\n  position: absolute;\n  margin-left: auto;\n  margin-right: auto;\n}", ""]); const o = n }, 645: t => { t.exports = function (t) { var s = []; return s.toString = function () { return this.map((function (s) { var e = t(s); return s[2] ? "@media ".concat(s[2], " {").concat(e, "}") : e })).join("") }, s.i = function (t, e, i) { "string" == typeof t && (t = [[null, t, ""]]); var n = {}; if (i) for (var o = 0; o < this.length; o++) { var h = this[o][0]; null != h && (n[h] = !0) } for (var r = 0; r < t.length; r++) { var c = [].concat(t[r]); i && n[c[0]] || (e && (c[2] ? c[2] = "".concat(e, " and ").concat(c[2]) : c[2] = e), s.push(c)) } }, s } }, 379: t => { var s = []; function e(t) { for (var e = -1, i = 0; i < s.length; i++)if (s[i].identifier === t) { e = i; break } return e } function i(t, i) { for (var o = {}, h = [], r = 0; r < t.length; r++) { var c = t[r], a = i.o ? c[0] + i.o : c[0], u = o[a] || 0, l = "".concat(a, " ").concat(u); o[a] = u + 1; var d = e(l), p = { h: c[1], media: c[2], u: c[3] }; -1 !== d ? (s[d].l++, s[d].p(p)) : s.push({ identifier: l, p: n(p, i), l: 1 }), h.push(l) } return h } function n(t, s) { var e = s.m(s); return e.update(t), function (s) { if (s) { if (s.h === t.h && s.media === t.media && s.u === t.u) return; e.update(t = s) } else e.remove() } } t.exports = function (t, n) { var o = i(t = t || [], n = n || {}); return function (t) { t = t || []; for (var h = 0; h < o.length; h++) { var r = e(o[h]); s[r].l-- } for (var c = i(t, n), a = 0; a < o.length; a++) { var u = e(o[a]); 0 === s[u].l && (s[u].p(), s.splice(u, 1)) } o = c } } }, 569: t => { var s = {}; t.exports = function (t, e) { var i = function (t) { if (void 0 === s[t]) { var e = document.querySelector(t); if (window.HTMLIFrameElement && e instanceof window.HTMLIFrameElement) try { e = e.contentDocument.head } catch (t) { e = null } s[t] = e } return s[t] }(t); if (!i) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."); i.appendChild(e) } }, 216: t => { t.exports = function (t) { var s = document.createElement("style"); return t.v(s, t.attributes), t.g(s), s } }, 565: (t, s, e) => { t.exports = function (t) { var s = e.M; s && t.setAttribute("nonce", s) } }, 795: t => { t.exports = function (t) { var s = t.O(t); return { update: function (e) { !function (t, s, e) { var i = e.h, n = e.media, o = e.u; n ? t.setAttribute("media", n) : t.removeAttribute("media"), o && "undefined" != typeof btoa && (i += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o)))), " */")), s.U(i, t) }(s, t, e) }, remove: function () { !function (t) { if (null === t.parentNode) return !1; t.parentNode.removeChild(t) }(s) } } } }, 589: t => { t.exports = function (t, s) { if (s.styleSheet) s.styleSheet.cssText = t; else { for (; s.firstChild;)s.removeChild(s.firstChild); s.appendChild(document.createTextNode(t)) } } } }, s = {}; function e(i) { var n = s[i]; if (void 0 !== n) return n.exports; var o = s[i] = { id: i, exports: {} }; return t[i](o, o.exports, e), o.exports } e.n = t => { var s = t && t.j ? () => t.default : () => t; return e.d(s, { a: s }), s }, e.d = (t, s) => { for (var i in s) e.k(s, i) && !e.k(t, i) && Object.defineProperty(t, i, { B: !0, get: s[i] }) }, e.k = (t, s) => Object.prototype.hasOwnProperty.call(t, s); var i = {}; (() => { e.d(i, { R: () => Yt, T: () => Xt, F: () => zt }); var t = e(379), s = e.n(t), n = e(795), o = e.n(n), h = e(569), r = e.n(h), c = e(565), a = e.n(c), u = e(216), l = e.n(u), d = e(589), p = e.n(d), m = e(28), f = {}; f.U = p(), f.v = a(), f.g = r().bind(null, "head"), f.m = o(), f.O = l(); s()(m.t, f); m.t && m.t.S && m.t.S; let v = 0; class w { constructor({ name: t = "" } = {}) { this.name = t, this.uuid = v, v += 1 } } class x { constructor(t = 0, s = 0) { this.x = t, this.y = s } set(t, s) { this.x = t, this.y = s } C() { return this.x + this.y } } const y = t => new Float32Array(t), b = () => Math.random(), g = (t, s, e) => { if (e) { const i = t.value; t.linearRampToValueAtTime(i, s), e.forEach((({ value: e, time: i, exp: n = !1 }) => { n ? t.exponentialRampToValueAtTime(e, s + i) : t.linearRampToValueAtTime(e, s + i) })) } }, M = t => { let s; return s = t > 0 ? 2 : .5, R * Math.pow(Math.pow(s, 1 / 12), Math.abs(t)) }, O = (t = k.context, s, e, i) => { const n = t.createBiquadFilter(); return n.frequency.value = e, n.type = s, i && n.connect(i), n }; class U { constructor() { this.context = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 }), this.A = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(2, 88200, 44100), this.L = this.context.createGain(), this.L.connect(this.context.destination), this.P = this.context.createConvolver(), this.P.connect(this.L) } async init() { const t = await this.q(); this.P.buffer = t, this.P.connect(this.L) } async q() { return new Promise((t => { const s = this.A.createGain(); s.connect(this.A.destination), s.gain.setValueAtTime(1, 0), s.gain.exponentialRampToValueAtTime(1e-4, 2); const e = O(this.A, "lowpass", 5e3, s), i = O(this.A, "highpass", 500, e), n = this.A.createBufferSource(); n.buffer = (t => { const s = 44100 * t, e = y(s), i = y(s); for (let t = 0; t < s; t++)e[t] = 1 - 2 * b(), i[t] = 1 - 2 * b(); const n = k.context.createBuffer(2, s, 44100); return n.getChannelData(0).set(e), n.getChannelData(1).set(i), n })(2), n.connect(i), n.start(), this.A.startRendering(), this.A.oncomplete = s => { t(s.renderedBuffer) } })) } } U.X = 196, U.Y = 2, U.I = 44100; const E = class { constructor() { this.V = [], this.D = 0 } N(t, s) { this.D++; const e = this.D, i = k.context.createBuffer(1, 1, 44100), n = k.context.createBufferSource(); return n.buffer = i, n.connect(k.context.destination), this.V.push({ id: e, time: t, type: "single", source: n }), n.onended = () => { s(), this.cancel(e) }, n.start(t - i.duration), e } $(t) { t.count++; const s = k.context.createBufferSource(); s.buffer = t.source.buffer, s.connect(k.context.destination), s.onended = () => { t.H(), this.$(t) }, s.start(t.time + t.count * t.frequency - s.buffer.duration), t.source = s } K(t, s, e) { const i = k.context.createBuffer(1, 1, 44100), n = k.context.createBufferSource(); n.buffer = i, n.connect(k.context.destination); const o = { id: ++this.D, count: 0, time: t, frequency: s, type: "repeating", H: e, source: n }; return n.onended = () => { e(), this.$(o) }, n.start(Math.max(0, t - i.duration)), this.V.push(o), o.id } J(t, s) { const e = this.Z(t); e && (e.H = s, e.source.onended = () => { s(), this.$(e) }) } Z(t) { return this.V.find((s => s.id === t)) } clear() { this.V.forEach((t => { t.source.onended = null, t.source.stop(), t.source.disconnect() })), this.V.length = 0 } cancel(t) { const s = this.Z(t); if (s) { s.source.onended = null; try { s.source.stop() } catch (t) { } s.source.disconnect(), this.V = this.V.filter((t => t.id !== s.id)) } } }, j = [0, 4, 5, 7, 10], k = new U, B = new E, R = 196, T = { G: document.getElementById("canvas-tiles"), W: document.getElementById("canvas-pre"), _: document.getElementById("canvas-post"), tt: document.getElementById("canvas-stats"), st: document.getElementById("canvas-oscillators"), et: document.getElementById("canvas-instruments"), it: document.getElementById("menu-button"), nt: document.getElementById("menu-col"), ot: document.getElementById("menu"), co: document.getElementById("co"), to: document.getElementById("to"), so: document.getElementById("so"), in: document.getElementById("in") }, F = { ht: T.G.getContext("2d"), rt: T._.getContext("2d"), ct: T._.getContext("2d"), at: T.tt.getContext("2d"), ut: T.st.getContext("2d"), lt: T.et.getContext("2d") }, S = t => t - 127, C = t => t - 127, A = t => t + 127, L = t => t + 127, P = t => Xt.width(.5) + (t - Yt.position.x) * Xt.width(.05) - Xt.width(.025), Q = t => Xt.height(.5) + (Yt.position.y - t) * Xt.width(.05) - Xt.width(.025), q = t => { const { left: s, right: e } = T.G.getBoundingClientRect(); if (!(t < s || t > e)) { const e = Xt.width() / Xt.width(.05), i = 2 * (t - s) / Xt.width(), n = -e / 2 + i * e + Yt.position.x; return Math.round(n) } }, z = t => { const { top: s, bottom: e } = T.G.getBoundingClientRect(); if (!(t < s || t > e)) { const i = Xt.height() / Xt.width(.05), n = 2 * (e - t - s) / Xt.height(), o = -i / 2 + n * i + Yt.position.y; return Math.round(o) } }, X = t => P(S(t)), Y = t => Q(C(t)), I = t => { t.width = t.clientWidth * window.devicePixelRatio || 1, t.height = t.clientHeight * window.devicePixelRatio || 1 }, V = "rgba(0,0,0,0)", D = "#FFFFFF", N = "#272838", $ = "#3f415b", H = "#ff4c7a", K = "#00f9ff", J = "#00e19e", Z = "#B0C4DE", G = { dt: 0 }, W = 2 * Math.PI, _ = (t, s, e = !1, i = !0, n = F.ht) => { i && n.strokeRect(t, s, Xt.width(.05), Xt.width(.05)), e && n.fillRect(t, s, Xt.width(.05), Xt.width(.05)) }, tt = t => { t.beginPath(), t.arc(Xt.ft(0), Xt.vt(0), Xt.width(.45), 0, W), t.clip() }; const st = [{ id: "in1", wt: { xt: !0, canvas: document.createElement("canvas") } }, { id: "in2", wt: { xt: !0, canvas: document.createElement("canvas") } }, { id: "in3", wt: { xt: !0, canvas: document.createElement("canvas") } }, { id: "in4", wt: { xt: !0, canvas: document.createElement("canvas") } }]; class et extends w { constructor(t = {}) { super(t); const { x: s, y: e, yt: i = !1, id: n = "" } = t; this.id = n, this.yt = i, this.position = new x(s, e) } } class it extends et { constructor(t) { super(t), this.name = "instrument" } init() { this.bt = (t => { let s = 0, e = 0, i = 0, n = 0; return t.forEach((t => { const [o, h] = t; o < s && (s = o), o > i && (i = o), h < e && (e = h), h > n && (n = h) })), { gt: s, Mt: i, Ot: e, Ut: n } })(this.outline), this.shape = ((t, s, e) => { const { gt: i, Mt: n, Ot: o, Ut: h } = e, r = [], c = new Path2D; ((t, s) => { for (let e = 0; e < s.length; e++) { const [i, n] = s[e]; 0 === e ? t.moveTo(i, n) : t.lineTo(i, n) } })(c, s); for (let s = i; s < n; s++)for (let e = o; e < h; e++)t.isPointInPath(c, s + .5, e + .5) && r.push([s, e + 1]); return r })(F.lt, this.outline, this.bt), this.Et = this.bt.Mt - this.bt.gt, this.jt = this.bt.Ut - this.bt.Ot, this.cache = st.find((({ id: t }) => t === this.id)), this.yt || this.kt() } Bt() { const { Rt: t, Tt: s, Ft: e, St: i } = Yt.Ct, { x: n, y: o } = this.position, h = A(n), r = L(o), c = zt[h][r], a = h > t && h < s && r > e && r < i, u = Boolean(c.At), l = c.Lt || !1, d = this.shape.some((([t, s]) => zt[h + t][r + s].Lt || Boolean(zt[h + t][r + s].At))); return a && !u && !l && !d } kt() { this.yt = !1; const t = A(this.position.x), s = L(this.position.y); zt[t][s].At = this, this.shape.forEach((([e, i]) => { zt[t + e][s + i].Lt = !0 })) } Pt(t = F.lt) { t.fillStyle = this.disabled ? Z : N, t.beginPath(); for (let s = 0; s < this.outline.length; s++) { const [e, i] = this.outline[s], n = P(this.position.x + e), o = Q(this.position.y + i); 0 === s ? t.moveTo(n, o) : t.lineTo(n, o) } t.closePath(), t.fill(), t.globalCompositeOperation = "source-atop", this.cache.wt.xt && (this.cache.wt.canvas.width = this.Et * Xt.width(.05), this.cache.wt.canvas.height = this.jt * Xt.width(.05), (t => { const s = t.getContext("2d"); s.fillStyle = $, s.fillRect(0, 0, t.width, t.height) })(this.cache.wt.canvas), this.cache.wt.xt = !1), this.disabled || t.drawImage(this.cache.wt.canvas, P(this.position.x - (this.Et - 1) / 2), Q(this.position.y + (this.jt - 1) / 2)), t.globalCompositeOperation = "source-over", t.stroke(); const s = P(this.position.x + .5), e = Q(this.position.y - .5); t.fillStyle = D, t.beginPath(), t.arc(s, e, Xt.width(.0125), 0, W), t.fill(), t.fillStyle = N; const i = this.display.substr(0, 1), n = t.measureText(i); t.fillText(this.display.substr(0, 1), s, e + n.actualBoundingBoxAscent / 2) } } class nt { constructor(t = {}) { this.note = t.note, this.Qt = 0, this.qt = { zt: 1, Xt: 0, Yt: 2e4, It: 20, Vt: 1.7, Dt: 1.7, Nt: 1.7, $t: 1.7 } } play(t, s = this.Ht()) { } Kt(t, s, e = {}) { s.gain.gain.value *= this.qt.zt; const i = k.context.createGain(); g(i.gain, t, this.Jt.amplitude); const n = k.context.createGain(); n.gain.value = 1 - this.qt.Xt; const o = k.context.createGain(); o.gain.value = this.qt.Xt; const h = k.context.createBiquadFilter(); h.type = "lowpass", h.frequency.value = 2e4, h.Q.value = this.Zt("lpEnvQ", e.Dt); const r = k.context.createBiquadFilter(); r.type = "lowpass", r.frequency.value = this.Zt("lpFrequency", e.Yt), r.Q.value = this.Zt("lpQ", e.Vt); const c = k.context.createBiquadFilter(); c.type = "highpass", c.frequency.value = 20, c.Q.value = this.Zt("hpEnvQ", e.Nt); const a = k.context.createBiquadFilter(); a.type = "highpass", a.frequency.value = this.Zt("hpFrequency", e.It), a.Q.value = this.Zt("hpQ", e.$t), this.Jt?.Gt && g(h.frequency, t, this.Jt.Gt), this.Jt?.Wt && g(c.frequency, t, this.Jt.Wt); const { source: u, gain: l } = s; u.connect(l), l.connect(i), i.connect(h), h.connect(c), c.connect(r), r.connect(a), a.connect(o), a.connect(n), n.connect(k.L), o.connect(k.P), u.start(t), u.stop(t + this.duration), u.onended = () => { u.disconnect(), i.disconnect() } } _t(t, s, e, i = {}) { let n; const o = k.context.createGain(), h = this.Ht(e); if ("waveform" === t) { const { ts: t } = i; n = k.context.createOscillator(), n.type = t, n.frequency.value = M(h) } if ("harmonics" === t) { const { ss: t, ts: s } = i; if (n = k.context.createOscillator(), n.type = s, !t) throw new Error("harmonic option required"); o.gain.value = .2 / (1 + Math.log2(t)), n.frequency.value = M(h) * t } if ("waveform" !== t && "harmonics" !== t || (this.duration = this.Jt.amplitude?.map((({ time: t }) => t)).reduce(((t, s) => t + s)) || 0), "sample" === t) { const { buffer: t } = i; n = k.context.createBufferSource(), n.buffer = t, this.duration = t.duration } return { source: n, gain: o, note: e } } Zt(t, s) { return void 0 !== s ? s : this.qt[t] } Ht(t) { return void 0 !== t ? this.Qt + t : void 0 !== this.note ? this.Qt + this.note : this.Qt + j[Math.floor(Math.random() * j.length)] } } class ot extends nt { constructor(t = {}) { super(t), this.Qt = -24, this.Jt = { amplitude: [{ time: 0, value: 1 }, { time: .75, value: 1e-4, exp: !0 }] } } play(t, s) { const e = this._t("waveform", t, s, { ts: "sine" }); this.Kt(t, e) } } class ht extends it { constructor(t = {}) { super(t), this.display = "Kick", this.id = "in1", this.es = 5, this.dt = 1, this.outline = [[0, 0], [1, 0], [1, -1], [0, -1]], this.ns = new ot({ note: 0 }), this.init() } } class rt extends nt { constructor(t = {}) { super(t), this.Qt = 0, this.Jt = { amplitude: [{ time: 0, value: 1 }, { time: .45, value: 1e-4, exp: !0 }] }, this.qt.It = 90, this.qt.Xt = .05, this.qt.zt = .4 } play(t, s = this.Ht()) { const e = this._t("waveform", t, s, { ts: "sine" }); e.gain.gain.value = .4; const i = this._t("sample", t, s, { buffer: k.P.buffer }); i.source.detune.value = 100 * s, this.Kt(t, e), this.Kt(t, i) } } class ct extends it { constructor(t = {}) { super(t), this.display = "Snare", this.id = "in2", this.es = 25, this.dt = 5, this.outline = [[0, 0], [1, 0], [1, -1], [0, -1]], this.init(), this.ns = new rt({ note: 7 }) } } const at = (t, s, e) => t * e + s * (1 - e); class ut extends et { constructor(t = {}) { super(t), this.name = "oscillator", this.os = [], this.hs = Z } init() { this.yt || this.kt() } rs() { return k.context.currentTime % this.duration / this.duration } Bt() { const { Rt: t, Tt: s, Ft: e, St: i } = Yt.Ct, { x: n, y: o } = this.position, h = A(n), r = L(o), c = zt[h][r], a = h > t && h < s && r > e && r < i, u = Boolean(c.At), l = c.Lt || !1; return a && !u && !l } kt() { this.yt = !1, zt[A(this.position.x)][L(this.position.y)].At = this, this.os.forEach((t => { B.cancel(t) })), this.cs() } Pt() { const t = P(this.position.x + .5), s = Q(this.position.y - .5); this.us(t, s), this.ls(t, s), this.yt && (F.ut.globalAlpha = .5, this.ds.forEach((t => { const [s, e] = t; F.ut.beginPath(), _(P(this.position.x + s), Q(this.position.y + e), !0, !1, F.ut) })), F.ut.globalAlpha = 1) } ls(t, s) { F.ut.moveTo(t, s); const e = this.rs(); let i, n; for (let t = 0; t < this.ds.length; t++) { const s = (t + 1) / this.ds.length; if (e < s) { const o = (s - e) * this.ds.length; i = P(this.position.x + .5 + at(this.ds[t][0], this.ds[(t + 1) % this.ds.length][0], o)), n = Q(this.position.y - .5 + at(this.ds[t][1], this.ds[(t + 1) % this.ds.length][1], o)), F.ut.lineTo(i, n), F.ut.stroke(), F.ut.beginPath(), F.ut.arc(i, n, Xt.width(.0125), 0, W), F.ut.fill(); break } } } us(t, s) { } cs() { const t = A(this.position.x), s = L(this.position.y); console.log(this.rs(), this.ds.length); const e = Math.ceil(Math.max(this.rs() || .1) * this.ds.length), i = (t => { const s = k.context.currentTime / t; return (Math.floor(s) + 1) * t })(this.interval); for (let n = 0; n < this.ds.length; n++) { const o = i + n * this.interval, h = (n + e) % this.ds.length, r = this.ds[h], c = zt[t + r[0]][s + r[1]]; this.os.push(B.K(o, this.duration, (() => { "instrument" === c?.At?.name && "playing" !== c.state && (c.state = "playing", c.ps = k.context.currentTime + .7714285714285714, G.dt += c.At.dt, c.At.ns.play(k.context.currentTime)) }))) } } } class lt extends ut { constructor(t = {}) { super(t) } init() { this.ds = [[0, this.fs], [this.fs, 0], [0, -this.fs], [-this.fs, 0]], this.duration = this.interval * this.ds.length, super.init() } us(t, s, e = F.ut, i = Xt.width(.025 - .006), n = Xt.width(.006), o = (this.disabled ? this.hs : this.color)) { e.strokeStyle = o, e.fillStyle = o, e.lineWidth = n, e.beginPath(), e.arc(t, s, i, 0, W) } ls(t, s) { F.ut.moveTo(t, s); const e = ((t, s, e, i, n) => ({ x: Math.cos(n) * (t - e) - Math.sin(n) * (s - i) + e, y: Math.sin(n) * (t - e) + Math.cos(n) * (s - i) + i }))(t + Xt.width(.05 * this.fs), s, t, s, W * this.rs() - Math.PI / 2); F.ut.lineTo(e.x, e.y), F.ut.stroke(), F.ut.beginPath(), F.ut.arc(e.x, e.y, Xt.width(.0125), 0, W), F.ut.fill() } } class dt extends lt { constructor(t = {}) { super(t), this.id = "co1", this.es = 25, this.fs = 1, this.color = H, this.interval = .8571428571428571, this.init() } } const pt = { screenX: void 0, screenY: void 0, vs: void 0, ws: void 0 }, mt = new class { constructor(t, s) { this.x = t, this.y = s } }(9, 16); class ft extends nt { constructor(t = {}) { super(t), this.Qt = 0, this.Jt = { amplitude: [{ time: 0, value: 1 }, { time: .25, value: 1e-4, exp: !0 }] }, this.qt.Xt = .05 } play(t, s) { const e = this._t("sample", t, s, { buffer: k.P.buffer }); e.gain.gain.value = .4, e.source.detune.value = 2400, this.Kt(t, e) } } class vt extends it { constructor(t = {}) { super(t), this.display = "HiHat", this.id = "in3", this.es = 5, this.dt = 1, this.outline = [[0, 0], [1, 0], [1, -1], [0, -1]], this.ns = new ft({ note: 0 }), this.init() } } class wt extends nt { constructor(t = {}) { super(t), this.Qt = 0, this.Jt = { amplitude: [{ time: 0, value: 1 }, { time: .25, value: 1e-4, exp: !0 }] }, this.qt.Xt = .05 } play(t, s) { const e = this._t("waveform", t, s, { ts: "sine" }); this.Kt(t, e) } } class xt extends it { constructor(t = {}) { super(t), this.display = "Tom", this.id = "in4", this.es = 5, this.dt = 1, this.outline = [[0, 0], [1, 0], [1, -1], [0, -1]], this.ns = new wt({ note: 0 }), this.init() } } const yt = { in1: t => new ht(t), in2: t => new ct(t), xs: t => new vt(t), ys: t => new xt(t) }, bt = Object.values(yt).map((t => t({ yt: !0 }))); class gt extends lt { constructor(t = {}) { super(t), this.id = "co2", this.es = 250, this.fs = 2, this.interval = 1.7142857142857142, this.color = J, this.init() } } class Mt extends lt { constructor(t = {}) { super(t), this.id = "co3", this.es = 2500, this.fs = 3, this.interval = 3.4285714285714284, this.color = K, this.init() } } class Ot extends ut { constructor(t = {}) { super(t), this.width = 1 } us(t, s, e = F.ut, i = Xt.width(.05 * this.width - .012), n = Xt.width(.006), o = (this.disabled ? this.hs : this.color)) { e.strokeStyle = o, e.fillStyle = o, e.lineWidth = n, e.beginPath(), e.strokeRect(t - i / 2, s - i / 2, i, i), e.stroke() } } class Ut extends Ot { constructor(t = {}) { super(t), this.interval = .21428571428571427, this.id = "so1", this.es = 1e3, this.color = H, this.ds = [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]], this.duration = this.interval * this.ds.length, this.init() } } class Et extends Ot { constructor(t = {}) { super(t), this.interval = .42857142857142855, this.id = "so2", this.es = 1e4, this.color = J, this.ds = [[0, 2], [2, 2], [2, 0], [2, -2], [0, -2], [-2, -2], [-2, 0], [-2, 2]], this.duration = this.interval * this.ds.length, this.init() } } class jt extends Ot { constructor(t = {}) { super(t), this.interval = .42857142857142855, this.id = "so3", this.es = 1e5, this.color = K, this.ds = [[0, 3], [3, 3], [3, 0], [3, -3], [0, -3], [-3, -3], [-3, 0], [-3, 3]], this.duration = this.interval * this.ds.length, this.init() } } class kt extends ut { constructor(t = {}) { super(t), this.width = 1 } us(t, s, e = F.ut, i = Xt.width(.05 * this.width - .012), n = Xt.width(.006), o = (this.disabled ? this.hs : this.color)) { e.strokeStyle = o, e.fillStyle = o, e.lineWidth = n, e.beginPath(), ((t, s, e, i) => { const n = i * Math.sqrt(3) / 2; t.beginPath(), t.moveTo(s, e - n / 2), t.lineTo(s + i / 2, e + n / 2), t.lineTo(s - i / 2, e + n / 2), t.closePath() })(e, t, s, i), e.stroke() } } class Bt extends kt { constructor(t = {}) { super(t), this.interval = .5714285714285714, this.id = "to1", this.es = 50, this.color = H, this.ds = [[0, 1], [1, -1], [-1, -1]], this.duration = this.interval * this.ds.length, this.init() } } class Rt extends kt { constructor(t = {}) { super(t), this.interval = 1.1428571428571428, this.id = "to2", this.es = 500, this.color = J, this.ds = [[0, 2], [2, -2], [-2, -2]], this.duration = this.interval * this.ds.length, this.init() } } class Tt extends kt { constructor(t = {}) { super(t), this.interval = 2.2857142857142856, this.id = "to3", this.es = 5e3, this.color = K, this.ds = [[0, 3], [3, -3], [-3, -3]], this.duration = this.interval * this.ds.length, this.init() } } const Ft = { bs: t => new dt(t), gs: t => new gt(t), Ms: t => new Mt(t), Os: t => new Bt(t), Us: t => new Rt(t), Es: t => new Tt(t), js: t => new Ut(t), ks: t => new Et(t), Bs: t => new jt(t) }, St = Object.values(Ft).map((t => t({ yt: !0 }))); let Ct = !1; const At = () => { "hidden" === T.ot.style.visibility ? (T.ot.style.visibility = "visible", T.it.style.transform = "rotate(45deg)", Ct = !0, Lt()) : (T.ot.style.visibility = "hidden", T.it.style.transform = "rotate(0deg)", Ct = !1) }, Lt = () => { }, Pt = () => { [T.G, T.W, T._, T.tt, T.st, T.et, T.ot].forEach((t => { (t => { const s = t.parentElement; new ResizeObserver((() => { const { width: e, height: i } = s.getBoundingClientRect(), n = Math.min(e / mt.x, i / mt.y), o = n * mt.x, h = n * mt.y, r = window.devicePixelRatio || 1; t.width = o * r, t.height = h * r, t.style.width = o + "px", t.style.height = h + "px" })).observe(s) })(t) })), T.it.onclick = At; const t = t => { pt.screenX = t.x, pt.screenY = t.y, pt.vs = q(t.x), pt.ws = z(t.y) }; document.addEventListener("mousemove", t), document.addEventListener("mousedown", (s => { k.context.resume(); const e = .05 * T.G.clientWidth; if (!Ct) { let i = s.clientX, n = s.clientY; const { x: o, y: h } = Yt.position; console.log(o); const r = t => { const s = t.clientX - i, r = t.clientY - n; console.log(s), Yt.position.set(o - s / e, h + r / e), Yt.Rs() }, c = () => { document.removeEventListener("mousemove", r), document.addEventListener("mousemove", t) }; document.addEventListener("mousemove", r), document.addEventListener("mouseup", c, { once: !0 }), document.removeEventListener("mousemove", t) } })); const s = () => { (() => { const t = F.ct.createRadialGradient(Xt.ft(0), Xt.vt(0), Xt.width(.225), Xt.ft(0), Xt.vt(0), Xt.width(.45)); t.addColorStop(0, V), t.addColorStop(.25, V), t.addColorStop(1, N), I(T._), F.ct.lineWidth = Xt.width(.006), F.ct.strokeStyle = D, F.ct.fillStyle = t, F.ct.beginPath(), F.ct.arc(Xt.ft(0), Xt.vt(0), Xt.width(.45), 0, W), F.ct.fill(), F.ct.stroke() })(), st.forEach((t => { t.wt.xt = !0 })), Yt.Rs() }; new ResizeObserver(s).observe(T.G), window.addEventListener("resize", s), window.addEventListener("orientationchange", s) }, Qt = { it: { marginBottom: "5vh", cursor: "pointer", border: "1px solid white", position: "absolute", width: "10vh", height: "10vh", borderRadius: "50%", background: "rgba(255, 255, 255, 0.1)", fontSize: "24px", alignSelf: "flex-end", transitionDuration: "250ms" }, ot: { visibility: "hidden", background: "rgba(0,0,0,.75)", justifyContent: "flex-start" }, nt: { justifyContent: "flex-start" }, W: { background: N }, tt: { cursor: "grab" }, co: { width: "unset" }, to: { width: "unset" }, so: { width: "unset" } }, qt = () => { const t = [...St, ...bt]; t.forEach(((s, e) => { const i = s.id, n = s.name, o = document.createElement("button"), h = document.createElement("canvas"); o.append(h), o.id = i; const r = s.id.substr(0, 2); T[r].append(o), Object.assign(o.style, { width: "7.5vh", height: "7.5vh", background: N }), o.onclick = s => { s.stopPropagation(), At(), ((t, s) => { t.position.set(pt.vs, pt.ws), Yt.Ts = t; const e = () => { const s = Math.round(pt.vs), e = Math.round(pt.ws); t.position.set(s, e), t.disabled = !t.Bt() }, i = () => { if (t.disabled) document.addEventListener("click", i, { once: !0 }); else { const { x: i, y: n } = t.position; s({ x: i, y: n }), Yt.Ts = null, document.removeEventListener("mousemove", e) } }; document.addEventListener("mousemove", e), document.addEventListener("click", i, { once: !0 }) })(t[e], "instrument" === n ? yt[i] : Ft[i]) }; new ResizeObserver((() => { I(h), ((t, s) => { I(t); const e = t.getContext("2d"), i = s.id.substr(0, 2); if ("oscillator" === s.name && (s.us(t.width / 2, t.height / 1.75, e, t.width * ("co" === i ? .15 : .3), t.width / 15), e.stroke()), "instrument" === s.name) { t.width = T.et.width, t.height = T.et.height; const i = 5.5, { x: n, y: o } = mt; e.save(), e.setTransform(i, 0, 0, i * o / n, -(i - 1) * t.width / 2, -(i * o / n - 1) * t.height / 2), s.Pt(e), e.restore(), e.scale(1, o / n) } e.font = t.width / 5 + 'px "Verdana", sans-serif', e.fillStyle = D, e.textAlign = "center"; const n = (t => { const s = t / 1e6; if (s > 1) return s + "M"; const e = t / 1e3; return e > 1 ? e + "K" : t + "" })(s.es), o = e.measureText(n); e.fillText(n, t.width / 2, 1.75 * o.actualBoundingBoxAscent) })(h, s) })).observe(o) })) }, zt = Array.from({ length: 255 }).map((() => Array.from({ length: 255 }, Object))), Xt = new class { constructor(t) { this.canvas = t } ft(t) { return this.canvas.width * ((t + 1) / 2) } vt(t) { return this.canvas.height * ((t + 1) / 2) } width(t = 1) { return this.canvas.width * t } height(t = 1) { return this.canvas.height * t } }(T.G), Yt = new class extends w { constructor({ name: t = "camera", coords: s }) { super({ name: t }), this.coords = s, this.position = new x, this.Fs = new x, this.Ct = { Rt: void 0, Tt: void 0, Ft: void 0, St: void 0 }, this.Ss() } Ss() { const t = Math.round(this.position.x), s = Math.round(this.position.y); this.Ct = { Rt: Math.max(0, A(t - 9)), Tt: Math.min(254, A(t + 9)), Ft: Math.max(0, L(s - 9)), St: Math.min(254, L(s + 9)) } } Rs() { this.Ss(), I(T.G), F.ht.fillStyle = N, F.ht.strokeStyle = D, F.ht.lineWidth = Xt.width(.006), tt(F.ht), F.ht.fillRect(0, 0, Xt.width(), Xt.height()), Yt.Cs(((t, s, e) => { _(X(s), Y(e)) })) } Cs(t) { for (let s = this.Ct.Rt; s <= this.Ct.Tt; s++)for (let e = this.Ct.Ft; e <= this.Ct.St; e++)t(zt[s][e], s, e) } Pt() { (() => { I(T.tt), F.at.font = `${Xt.width(.035)}px ${FONT_STYLE}`, F.at.fillStyle = D; const t = "Notes: " + G.dt; F.at.fillText(t, Xt.ft(-.95), Xt.vt(-.95)) })(), this.Cs(((t, s, e) => { const { ps: i, At: n, state: o } = t; "instrument" === n?.name && ("playing" === o && ((t, s, e, i, n) => { const o = s.width(.0125 * 1.1); t.fillStyle = N, t.globalAlpha = 1, t.beginPath(), t.arc(e, i, o, 0, W), t.fill(), t.globalAlpha = 1, t.font = `${s.width(.0175)}px ${FONT_STYLE}`, t.textAlign = "center", t.fillStyle = D; const h = "+" + n, r = t.measureText(h); t.fillText(h, e, i + r.actualBoundingBoxAscent / 2) })(F.at, this.coords, P(S(s) + .5), Q(C(e) - .5), n.dt), i <= k.context.currentTime && "playing" === o && (t.state = "stopped")) })), I(T.st), F.ut.lineCap = "round", F.ut.lineJoin = "round", F.ut.lineWidth = Xt.width(.006), tt(F.ut), Yt.Cs((({ At: t }) => { "oscillator" === t?.name && t.Pt() })), I(T.et), F.lt.font = `${Xt.width(.0175)}px ${FONT_STYLE}`, F.lt.textAlign = "center", F.lt.fillStyle = N, F.lt.strokeStyle = D, F.lt.lineWidth = Xt.width(.006), F.lt.lineJoin = "round", tt(F.lt), Yt.Cs((({ At: t }) => { "instrument" === t?.name && t.Pt() })), this.Ts?.Pt() } }({ coords: Xt }); (async () => { await k.init(), Pt(), qt(), Object.entries(T).forEach((([t, s]) => { Object.assign(s.style, Qt[t]) })), document.body.style.background = "black", Lt(), Yt.Rs(), new ht({ x: 1, y: 0 }), new ct({ x: -1, y: 0 }), new dt({ x: 0, y: 0 }); let t = G.dt; const s = e => { t = G.dt, Yt.Pt(), Ct && G.dt !== t && Lt(), window.requestAnimationFrame(s) }; window.requestAnimationFrame(s) })() })() })();</script>
</body>

</html>